from PixelShader import PixelShader
from Ray import Ray
from Scene import Scene
from functools import reduce
import numpy as np
from Color import Color
from Vector3 import Vector3, extract
import time
from typing import Type
from PIL import Image


class RenderEngine:
    """The main render engine, which does the ray-tracing."""

    def __init__(self, scene: Scene, shader: Type[PixelShader], max_depth=3) -> None:
        """
        :param scene: The scene to be rendered, must be of type Scene.
        :param shader: The pixel shader to be used for shading, must be of type PixelShader and adhere to PixelShader contract.
        :param max_depth: The number of reflections the engine will calculate at most.
        """
        self.MAX_DEPTH = max_depth
        self.scene = scene
        self.shader = shader

    def _set_up_screen(self):
        aspect_ratio = float(self.scene.width) / self.scene.height
        screen = (-1, 1 / aspect_ratio, 1, -1 / aspect_ratio)
        x = np.tile(np.linspace(screen[0], screen[2], self.scene.width), self.scene.height)
        y = np.repeat(np.linspace(screen[1], screen[3], self.scene.height), self.scene.width)
        return Ray(self.scene.camera, Vector3(x, y, 0) - self.scene.camera)

    def render(self):
        """Starts the render with the provided parameters."""
        ray = self._set_up_screen()
        t0 = time.time()
        color = self._ray_trace(ray)
        print(f"The render took: {time.time() - t0} seconds.")
        return color

    def _ray_trace(self, ray: Ray, depth=0) -> Color:
        distances = [obj.intersects(ray) for obj in self.scene.objects]
        closest = reduce(np.minimum, distances)
        color = Color(0, 0, 0)
        for obj, dist in zip(self.scene.objects, distances):
            hit_mask = (dist == closest) * (closest != np.inf)
            if np.any(hit_mask):
                hit_points = extract(hit_mask, dist)
                filtered_ray = Ray(ray.origin.extract(hit_mask), ray.direction.extract(hit_mask))
                color += self.shader(filtered_ray, obj, hit_points, self.scene, self._ray_trace, depth,
                                     self.MAX_DEPTH).shade().place(hit_mask)
        return color

    @staticmethod
    def save_as(color: Color, width, height, filename: str):
        """
        Allows the color-data generated by RenderEngine to be saved a common file format.
        :param color: Pixel color-data from the completed render.
        :param width: Width used in the render.
        :param height: Height used in the render.
        :param filename: Filename to be saved as, must include file-format.
        :return: None
        """
        rgb = [Image.fromarray((255 * np.clip(color, 0, 1).reshape((height, width))).astype(np.uint8), "L") for color in
               color.components()]
        Image.merge("RGB", rgb).save(filename)

    def render_and_save_as(self, filename: str):
        """
        Starts the render, and immediately saves the result to file when completed.
        Warning: Should not be used in conjunction with render(), unless a re-render is desired.
        :param filename: Filename to be saved as, must include file-format.
        :return: None
        """
        color = self.render()
        self.save_as(color, self.scene.width, self.scene.height, filename)
